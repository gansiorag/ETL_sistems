# **RabbitMQ**
* Это брокер сообщений. Его основная цель ‒ принимать и отдавать сообщения. Его можно представлять себе, как почтовое отделение: когда Вы бросаете письмо в ящик, Вы можете быть уверены, что рано или поздно почтальон доставит его адресату [видимо, автор ни разу не имел дела с Почтой России]. В этой аналогии RabbitMQ является одновременно и почтовым ящиком, и почтовым отделением, и почтальоном.

**https://www.rabbitmq.com/install-windows.html**

## **Библиотека RabbitMQ**

RabbitMQ использует протокол AMQP. Для использования RabbitMQ необходима библиотека, поддерживающая этот протокол. Такие библиотеки можно найти практически для каждого языка программирования. Python ‒ не исключение, для него есть несколько библиотек:

* py-amqplib
* txAMQP
* pika

В примерах будет использована библиотека pika. Ее можно установить при помощи менеджера пакетов pip:

**sudo pip install pika**

* **Producer (поставщик)** ‒ программа, отправляющая сообщения. В схемах он будет представлен кругом с буквой «P»:

* **Queue (очередь)** ‒ имя «почтового ящика». Она существует внутри RabbitMQ. Хотя сообщения проходят через RabbitMQ и приложения, хранятся они только в очередях. Очередь не имеет ограничений на количество сообщений, она может принять сколь угодно большое их количество ‒ можно считать ее бесконечным буфером. Любое количество поставщиков может отправлять сообщения в одну очередь, также любое количество подписчиков может получать сообщения из одной очереди. В схемах очередь будет обозначена стеком и подписана именем:

* **Consumer (подписчик)** ‒ программа, принимающая сообщения. Обычно подписчик находится в состоянии ожидания сообщений. В схемах он будет представлен кругом с буквой «C»:

Поставщик, подписчик и брокер не обязаны находиться на одной физической машине, обычно они находятся на разных.

**Первый пример** не будет особо сложным ‒ давайте просто отправим сообщение, примем его и выведем на экран. Для этого нам потребуется две программы: одна будет отправлять сообщения, другая ‒ принимать и выводить их на экран.
Общая схема такова:

**P --> |||||| --> C**

Файлы *send.py , receive.py*


